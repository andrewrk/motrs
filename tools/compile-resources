#!/usr/bin/env python

import os,sys,re
from struct import pack, unpack, calcsize
from PIL import Image

def update_folder(in_folder, datfile):
    """
    make sure the resources.dat file has every file in in_folder
    and it is updated
    """
    for root, dirs, files in os.walk(in_folder):
        if root.startswith("."): continue
        for f in (os.path.join(root, x) for x in files):
            update_file(f, datfile)
        break

def update_file(f, datfile):
    if os.path.getmtime(f) > datfile_time:
        command = "%s update %s \"%s\"" % (os.path.abspath(resource_tool), os.path.abspath(datfile), os.path.abspath(f))
        if os.system(command):
            sys.exit(1)

def compile_folder(in_folder, out_folder, compile_func):
    """
    make sure every file in in_folder is compiled and up to date in 
    out_folder
    """
    for root, dirs, files in os.walk(in_folder):
        for f in files:
            if f.startswith("."): continue
            in_file = os.path.join(root, f)
            out_file = os.path.join(out_folder, f)

            in_file_modified = os.path.getmtime(in_file)
            out_file_modified = -1
            if os.path.exists(out_file):
                out_file_modified = os.path.getmtime(out_file)

            if in_file_modified > out_file_modified:
                print("Compiling %s..." % in_file)
                compile_func(in_file, out_file)
        break

def write_string(string, out_handle):
    out_handle.write(pack( "i" , len(string) ))
    for char in string:
        out_handle.write(pack("c" , char ))

def compile_hashmap(in_file, out_file):
    """
    compile file from text format into binary format 
    """
    build_path(out_file)
    out_handle = open(out_file, "wb")
    write_properties(open(in_file,"r").read(), out_handle)
    out_handle.close()

def compile_world(in_file, out_file):
    """
    compile a world. blah
    """
    build_path(out_file)
    out_handle = open(out_file, "wb")
    lines = read_lines(in_file)
    out_handle.write(pack("i", len(lines)))
    for line in lines:
        (x, y, z, id) = line.split()
        out_handle.write(pack("iii", int(x), int(y), int(z)))
        write_string(id, out_handle)
    out_handle.close()

def compile_map(in_file, out_file):
    def compress_layer(values, size_x, size_y):
        assert len(values) == size_x * size_y
        FMT_FULL = 1
        FMT_SPARSE = 2
        def sparse_values():
            for y in range(size_y):
                for x in range(size_x):
                    yield (x, y, values[y * size_x + x])
        sparse_version = "".join(pack("iii", x, y, v) for (x, y, v) in sparse_values() if v != 0)
        full_version = "".join(pack("i", v) for v in values)
        if len(sparse_version) > len(full_version):
            # full
            return pack("i", FMT_FULL) + full_version
        else:
            # sparse
            return pack("ii", FMT_SPARSE, len(sparse_version) / calcsize("iii")) + sparse_version
    lines = read_lines(in_file)
    pallet = []
    size = None
    layers = []
    submaps = []
    triggers = []
    entities = []
    for line in lines:
        (kind, value) = line.split("=", 1)
        if kind == "size":
            assert size == None
            (x, y) = value.split(",")
            size = (int(x), int(y))
        elif kind == "tile":
            raise "TODO: support tile"
        elif kind == "layer":
            values = value.split(",")
            layers.append(compress_layer([int(v) for v in values], size[0], size[1]))
        elif kind == "submap":
            raise "TODO: support submap"
        elif kind == "trigger":
            raise "TODO: support trigger"
        elif kind == "entity":
            raise "TODO: support entity"
        else:
            raise "unknown kind: " + kind


    out_handle = open_output(out_file)
    # header
    out_handle.write(pack("i" * 7, len(pallet), size[0], size[1], 
            len(layers), len(submaps), len(triggers), len(entities)))
    # pallet
    for tile in pallet:
        raise "TODO: support tile"
    for layer in layers:
        out_handle.write(layer)
    for submap in submaps:
        raise "TODO: support submap"
    for trigger in triggers:
        raise "TODO: support trigger"
    for entity in entities:
        raise "TODO: support entity"
    out_handle.close()

def read_lines(in_file):
    lines = open(in_file, "rU").read().split("\n")
    def strip_comments(line):
        comment_start = line.find("#")
        if comment_start != -1:
            line = line[:comment_start]
        return line.strip()
    lines = [strip_comments(line) for line in lines]
    return [line for line in lines if line != ""]

def open_output(out_file):
    build_path(out_file)
    return open(out_file, "wb")

def write_properties(text, out_handle):
    """
    compile from text format into binary format 
    """
    props = [[y.strip() for y in x.split("=")] for x in text.split("\n") if x.find('=') >= 0]

    out_handle.write(pack("i", 1)) #version
    out_handle.write(pack("i", len(props) )) # number properties

    color_re = re.compile('^\s*(\d+)\s*\,\s*(\d+)\s*\,\s*(\d+)\s*$')
    for propName,typeName,value in props:
        write_string(propName, out_handle)
        write_string(typeName, out_handle)
        if typeName == 'string':
            write_string(value, out_handle)
        elif typeName == 'color':
            if not (value.lower() in ("none", "false", "null", "0", "no")):
                matches = color_re.match(value)
                if matches == None:
                    sys.stderr.write("Error in %s, the property %s has an invalid value: %s\n" % (in_file, propName, value))
                    sys.exit(1)
                
                out_handle.write(pack("BBB", int(matches.group(1)), int(matches.group(2)), int(matches.group(3))))
        elif typeName == 'int':
            out_handle.write(pack("i", int(value)))
        elif typeName == 'float':
            out_handle.write(pack("f", float(value)))
        elif typeName == 'bool':
            out_val = 0
            if value.lower() in ("true", "1", "yes", "y", "t"):
                out_val = 1
            out_handle.write(pack("b", out_val))
        elif typeName == 'array_string':
            strings = [x.strip() for x in value.split(",")]
            count = len(strings)
            # array length
            out_handle.write(pack("i", int(count)))
            for string in strings:
                write_string(string, out_handle)
        else:
            sys.stderr.write("ERROR: Unsupported property type: %s\n" % typeName)
            sys.exit(1)


def compile_animation_folder(in_folder, out_folder):
    for root, dirs, files in os.walk(in_folder):
        for d in dirs:
            in_dir = os.path.join(root, d)
            out_file = os.path.join(out_folder, d)

            out_file_modified = -1
            if os.path.exists(out_file):
                out_file_modified = os.path.getmtime(out_file)

            # if any file in in_dir is later than out_file_modified
            for ani_root, ani_dirs, ani_files in os.walk(in_dir):
                for f in ani_files:
                    if os.path.getmtime(os.path.join(ani_root, f)) > out_file_modified:
                        print("Compiling %s..." % in_dir)
                        compile_animation(in_dir, out_file)
                        break
                    
                break

        break

def compile_animation(in_dir, out_file):
    # get a list of all the bitmaps
    bitmaps = []
    prop_file = None
    for root, dirs, files in os.walk(in_dir):
        for f in files:
            if f == "properties.txt":
                prop_file = os.path.join(root, f)
            else:
                bitmaps.append(os.path.join(root, f))
        break
    
    if prop_file == None:
        sys.stderr.write("Error: %s does not have a properties.txt\n" % in_dir)
        sys.exit(1)

    # sort the list of bitmaps
    bitmaps.sort()

    if len(bitmaps) == 0:
        sys.stderr.write("Error: Animation %s does not have any frames." % in_dir)
        sys.exit(1)

    # create a sprite sheet out of the bitmaps
    # open the first file to determine width and height
    first_image = Image.open(bitmaps[0])
    frame_width, frame_height = first_image.size
    sheet_width = frame_width * len(bitmaps)

    spritesheet = Image.new("RGB", (sheet_width, frame_height))
    x = 0
    for bmp_file in bitmaps:
        bmp_image = Image.open(bmp_file)
        spritesheet.paste(bmp_image, (x, 0))
        x += frame_width

    # read the properties
    props = {}
    for name, propType, value in [[y.strip() for y in x.split("=")] for x in open(os.path.join(in_dir, "properties.txt")).read().split("\n") if x.find('=') >= 0]:
        props[name] = value

    # write the header to out_file
    build_path(out_file)
    out = open(out_file, "wb")

    r,g,b = [int(x.strip()) for x in props['alphacolor'].split(',')]

    #RGB colorKey;
    out.write(pack("BBB", r, g, b))
    #Uint32 frameCount;
    out.write(pack("i", len(bitmaps)))
    #Uint32 framesPerSecond;
    out.write(pack("i", int(props['fps'])))
    #Uint32 frameWidth;
    out.write(pack("i", frame_width))
    #Uint32 frameHeight;
    out.write(pack("i", frame_height))
    #Uint32 bitmapSize; // size in bytes of the following .bmp file
    # come back to this one later
    out_bitmapSize_pos = out.tell()
    # write the spritesheet bitmap
    spritesheet.save(out, "BMP")
    bitmap_size_bytes = out.tell() - out_bitmapSize_pos
    out.seek(out_bitmapSize_pos)
    out.write(pack("i", bitmap_size_bytes))

    out.close()

def build_path(file_path):
    """
    ensure that folders exist so that this file_path can be written to
    """
    d = os.path.dirname(file_path)
    if not os.path.exists(d):
        os.makedirs(d)


# things that just need to be copied
static_resources = (
    "bitmaps",
)

# things that simply need to be hashmap-compiled
compiled_resources = (
    ("tiles", compile_hashmap),
    ("universes", compile_hashmap),
    ("characters", compile_hashmap),
    ("worlds", compile_world),
    ("maps", compile_map),
)

command, datfile, in_dir, out_dir = sys.argv
resource_tool = os.path.join(out_dir, "resource-edit")

datfile_time = 0
if os.path.exists(datfile):
    datfile_time = os.path.getmtime(datfile)

in_resources, out_resources = [os.path.join(x, "resources") for x in (in_dir, out_dir)]
compile_animations = os.path.join(in_dir, "tools", "compile-animations")
compile_props = os.path.join(in_dir, "tools", "compile-props")

# compile static resources
for item in static_resources:
    print("Checking %s..." % item)
    update_folder(os.path.join(in_resources, item), datfile)

# compile hashmap resources
for (item, func) in compiled_resources:
    print("Checking %s..." % item)
    in_files, out_files = (os.path.join(in_resources, item), os.path.join(out_resources, item))
    compile_folder(in_files, out_files, func)
    update_folder(out_files, datfile)

# compile animations
print("Checking animations...")
in_ani, out_ani = (os.path.join(in_resources, "animations"), os.path.join(out_resources, "animations"))
compile_animation_folder(in_ani, out_ani)
update_folder(out_ani, datfile)
