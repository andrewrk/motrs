#!/usr/bin/env python

import os,sys,re
from struct import pack, unpack
from PIL import Image

def update_folder(in_folder, datfile):
    """
    make sure the resources.dat file has every file in in_folder
    and it is updated
    """
    for root, dirs, files in os.walk(in_folder):
        update_files([os.path.join(root, x) for x in files], datfile)
        break

def update_files(files, datfile):
    """
    make sure the resources.dat file has every file in files and it
    is updated.
    """
    for f in files:
        update_file(f, datfile)

def update_file(f, datfile):
    if os.path.getmtime(f) > datfile_time:
        command = "%s update %s \"%s\"" % (os.path.abspath(resource_tool), os.path.abspath(datfile), os.path.abspath(f))
        if os.system(command):
            sys.exit(1)

def compile_folder(in_folder, out_folder, compile_func):
    """
    make sure every file in in_folder is compiled and up to date in 
    out_folder
    """
    for root, dirs, files in os.walk(in_folder):
        for f in files:
            in_file = os.path.join(root, f)
            out_file = os.path.join(out_folder, f)

            in_file_modified = os.path.getmtime(in_file)
            out_file_modified = -1
            if os.path.exists(out_file):
                out_file_modified = os.path.getmtime(out_file)

            if in_file_modified > out_file_modified:
                print("Compiling %s..." % in_file)
                compile_func(in_file, out_file)
        break

def store_string(string, out_handle):
    out_handle.write(pack( "i" , len(string) ))
    for char in string:
        out_handle.write(pack("c" , char ))

def compile_hashmap(in_file, out_file):
    """
    compile file from text format into binary format 
    """
    build_path(out_file)
    out_handle = open(out_file, "wb")
    write_properties(open(in_file,"r").read(), out_handle)
    out_handle.close()

def compile_world(in_file, out_file):
    """
    compile a world. blah
    """
    build_path(out_file)
    out_handle = open(out_file, "wb")
    lines = open(in_file, "rU").read().split("\n")
    lines = [line for line in lines if line != ""]
    out_handle.write(path("i", len(lines)))
    for line in lines:
        line = line.strip()
        (x, y, z, id) = line.split()
        out_handle.write(pack("iii", (int(x), int(y), int(z))))
        store_string(id, out_handle)
    out_handle.close()

def write_properties(text, out_handle):
    """
    compile from text format into binary format 
    """
    props = [[y.strip() for y in x.split("=")] for x in text.split("\n") if x.find('=') >= 0]

    out_handle.write(pack("i", 1)) #version
    out_handle.write(pack("i", len(props) )) # number properties

    color_re = re.compile('^\s*(\d+)\s*\,\s*(\d+)\s*\,\s*(\d+)\s*$')
    for propName,typeName,value in props:
        store_string(propName, out_handle)
        store_string(typeName, out_handle)
        if typeName == 'string':
            store_string(value, out_handle)
        elif typeName == 'color':
            if not (value.lower() in ("none", "false", "null", "0", "no")):
                matches = color_re.match(value)
                if matches == None:
                    sys.stderr.write("Error in %s, the property %s has an invalid value: %s\n" % (in_file, propName, value))
                    sys.exit(1)
                
                out_handle.write(pack("BBB", int(matches.group(1)), int(matches.group(2)), int(matches.group(3))))
        elif typeName == 'int':
            out_handle.write(pack("i", int(value)))
        elif typeName == 'float':
            out_handle.write(pack("f", float(value)))
        elif typeName == 'bool':
            out_val = 0
            if value.lower() in ("true", "1", "yes", "y", "t"):
                out_val = 1
            out_handle.write(pack("b", out_val))
        elif typeName == 'array_string':
            strings = [x.strip() for x in value.split(",")]
            count = len(strings)
            # array length
            out_handle.write(pack("i", int(count)))
            for string in strings:
                store_string(string, out_handle)
        else:
            sys.stderr.write("ERROR: Unsupported property type: %s\n" % typeName)
            sys.exit(1)


def compile_animation_folder(in_folder, out_folder):
    for root, dirs, files in os.walk(in_folder):
        for d in dirs:
            in_dir = os.path.join(root, d)
            out_file = os.path.join(out_folder, d)

            out_file_modified = -1
            if os.path.exists(out_file):
                out_file_modified = os.path.getmtime(out_file)

            # if any file in in_dir is later than out_file_modified
            for ani_root, ani_dirs, ani_files in os.walk(in_dir):
                for f in ani_files:
                    if os.path.getmtime(os.path.join(ani_root, f)) > out_file_modified:
                        print("Compiling %s..." % in_dir)
                        compile_animation(in_dir, out_file)
                        break
                    
                break

        break

def compile_animation(in_dir, out_file):
    # get a list of all the bitmaps
    bitmaps = []
    prop_file = None
    for root, dirs, files in os.walk(in_dir):
        for f in files:
            if f == "properties.txt":
                prop_file = os.path.join(root, f)
            else:
                bitmaps.append(os.path.join(root, f))
        break
    
    if prop_file == None:
        sys.stderr.write("Error: %s does not have a properties.txt\n" % in_dir)
        sys.exit(1)

    # sort the list of bitmaps
    bitmaps.sort()

    if len(bitmaps) == 0:
        sys.stderr.write("Error: Animation %s does not have any frames." % in_dir)
        sys.exit(1)

    # create a sprite sheet out of the bitmaps
    # open the first file to determine width and height
    first_image = Image.open(bitmaps[0])
    frame_width, frame_height = first_image.size
    sheet_width = frame_width * len(bitmaps)

    spritesheet = Image.new("RGB", (sheet_width, frame_height))
    x = 0
    for bmp_file in bitmaps:
        bmp_image = Image.open(bmp_file)
        spritesheet.paste(bmp_image, (x, 0))
        x += frame_width

    # read the properties
    props = {}
    for name, propType, value in [[y.strip() for y in x.split("=")] for x in open(os.path.join(in_dir, "properties.txt")).read().split("\n") if x.find('=') >= 0]:
        props[name] = value

    # write the header to out_file
    build_path(out_file)
    out = open(out_file, "wb")

    r,g,b = [int(x.strip()) for x in props['alphacolor'].split(',')]

    #RGB colorKey;
    out.write(pack("BBB", r, g, b))
    #Uint32 frameCount;
    out.write(pack("i", len(bitmaps)))
    #Uint32 framesPerSecond;
    out.write(pack("i", int(props['fps'])))
    #Uint32 frameWidth;
    out.write(pack("i", frame_width))
    #Uint32 frameHeight;
    out.write(pack("i", frame_height))
    #Uint32 bitmapSize; // size in bytes of the following .bmp file
    # come back to this one later
    out_bitmapSize_pos = out.tell()
    # write the spritesheet bitmap
    spritesheet.save(out, "BMP")
    bitmap_size_bytes = out.tell() - out_bitmapSize_pos
    out.seek(out_bitmapSize_pos)
    out.write(pack("i", bitmap_size_bytes))

    out.close()

def build_path(file_path):
    """
    ensure that folders exist so that this file_path can be written to
    """
    d = os.path.dirname(file_path)
    if not os.path.exists(d):
        os.makedirs(d)


# things that just need to be copied
static_resources = (
    "bitmaps",
    "maps",
    "worlds",
)

# things that simply need to be hashmap-compiled
compiled_resources = (
    ("tiles", compile_hashmap),
    ("universes", compile_hashmap),
    ("characters", compile_hashmap),
    ("worlds", compile_world),
)

command, datfile, in_dir, out_dir = sys.argv
resource_tool = os.path.join(out_dir, "resource-edit")
datfile_time = os.path.getmtime(datfile)

in_resources, out_resources = [os.path.join(x, "resources") for x in (in_dir, out_dir)]
compile_animations = os.path.join(in_dir, "tools", "compile-animations")
compile_props = os.path.join(in_dir, "tools", "compile-props")

# compile static resources
for item in static_resources:
    print("Checking %s..." % item)
    update_folder(os.path.join(in_resources, item), datfile)

# compile hashmap resources
for (item, func) in compiled_resources:
    print("Checking %s..." % item)
    in_files, out_files = (os.path.join(in_resources, item), os.path.join(out_resources, item))
    compile_folder(in_files, out_files, func)
    update_folder(out_files, datfile)

# compile animations
print("Checking animations...")
in_ani, out_ani = (os.path.join(in_resources, "animations"), os.path.join(out_resources, "animations"))
compile_animation_folder(in_ani, out_ani)
update_folder(out_ani, datfile)
